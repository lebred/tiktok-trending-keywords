# Database Portability Guide

This document ensures the codebase remains portable between SQLite (MVP) and PostgreSQL (production).

## Schema Portability

### ✅ Portable Types Used

All models use only cross-database compatible types:

- **Integer** - Primary keys, foreign keys, counts
- **String** - Text fields (VARCHAR in PostgreSQL, TEXT in SQLite)
- **Float** - Decimal/numeric values
- **Date** - Date fields
- **DateTime** - Timestamp fields
- **JSON** - JSON data (SQLAlchemy handles conversion: TEXT in SQLite, JSONB in PostgreSQL)
- **Enum** - Enumeration types (stored as VARCHAR/TEXT)

### ✅ Portable Features

- **Foreign Keys** - Standard SQL foreign key constraints
- **Unique Constraints** - Standard SQL unique constraints
- **Indexes** - Standard SQL indexes
- **Relationships** - SQLAlchemy ORM relationships (no DB-specific code)

### ❌ Avoid These (Not Used)

- **UUID columns** - Use Integer IDs instead (generated by database)
- **PostgreSQL-specific types**: JSONB, ARRAY, GIN indexes, etc.
- **Database functions**: `uuid_generate_v4()`, `ILIKE`, etc.
- **Raw SQL** - Use SQLAlchemy ORM or portable SQL only

## JSON Column Portability

The `google_trends_data` column uses SQLAlchemy's `JSON` type:

- **SQLite**: Stored as TEXT (SQLAlchemy handles JSON serialization)
- **PostgreSQL**: Stored as JSONB (SQLAlchemy handles conversion)

**No code changes needed** - SQLAlchemy abstracts the difference.

## UUID Generation

**No UUIDs in database** - All IDs are Integer types, auto-generated by the database.

If UUIDs are needed in the future:
- Generate in Python code: `import uuid; str(uuid.uuid4())`
- Store as String(36) column
- Never use database-specific UUID functions

## Migration Safety

### Schema Migration

✅ **Safe**: Using Alembic with portable types means:
- Migrations work on both SQLite and PostgreSQL
- No schema changes needed when switching databases
- Same migration files work for both

### Data Migration

✅ **Safe**: The migration script (`migrate_from_sqlite_to_postgres.py`) handles:
- Type conversions (SQLAlchemy handles JSON automatically)
- Foreign key relationships
- Enum values
- All data types

## Testing Portability

To verify portability:

1. **Test on SQLite**:
   ```bash
   DATABASE_URL=sqlite:///./test.db alembic upgrade head
   pytest
   ```

2. **Test on PostgreSQL**:
   ```bash
   DATABASE_URL=postgresql://... alembic upgrade head
   pytest
   ```

Both should pass with identical results.

## Best Practices

1. **Always use SQLAlchemy types** - Never raw SQL types
2. **Test migrations on both databases** - Before deploying
3. **Avoid database-specific features** - Until you commit to one database
4. **Generate IDs in app** - If you need UUIDs, generate in Python
5. **Use portable SQL** - If raw SQL is needed, test on both databases

## Current Schema Status

✅ **All models are portable**:
- `BaseModel` - Integer ID, DateTime timestamps
- `Keyword` - String keyword, Integer ID
- `DailySnapshot` - Integer/Float/Date/JSON fields
- `User` - String email, Enum tier
- `Subscription` - Integer foreign keys, Enum status

**No portability issues detected.**

